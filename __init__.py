# __init__.py に記述する内容

def myai(board, color):
    """
    オセロAIのメイン関数。
    ボードの状態と、自分が打つべき色を受け取り、次に打つべき手の座標を返す。

    Args:
        board (list of list of int): 8x8のオセロ盤の状態。
                                      0: 空、1: 黒（先手）、2: 白（後手）
        color (int): 自分が打つ色 (1: 黒, 2: 白)

    Returns:
        tuple or None: (row, col) の形式で、次に石を置く座標を返す。
                       打てる場所がない場合は None を返す。
    """
    
    # --- 1. 現状で打てる手のリストを取得 ---
    
    # 実際には、この部分で「board」と「color」を解析し、
    # どこに打てば石が裏返るかを計算して、合法な手のリストを生成する必要があります。
    # 例： [(r0, c0), (r1, c1), ...]
    
    # **【一時的なダミーコード】:**
    # 現段階では動作確認のために、盤面の左上から順に空きマスを探す単純なロジックを記述します。
    # 正しいオセロAIを実装する際には、このロジックを削除・修正してください。
    
    valid_moves = []
    
    # 8x8の盤面を探索
    for r in range(8):
        for c in range(8):
            # 盤面が空（0）であるかチェック
            if board[r][c] == 0:
                # 本来はここで「color」を置いたときに石が裏返るかチェックが必要
                # ダミーとして、空きマスであれば一旦「打てる場所」とみなす
                valid_moves.append((r, c))
    
    # ----------------------------------------
    
    
    # --- 2. 打てる手の中から、最適/次に打つ手を決定 ---
    
    if not valid_moves:
        # 打てる手がない場合（パス）
        return None
    
    # 【現在の選択ロジック（ランダムまたはシンプルな選択）】
    # ここに、ミニマックス法や評価関数などの高度なAIロジックを実装します。
    
    # 現状は、見つけた最初の合法な手（左上の空きマス）を返す
    # 正しく実装するなら、ここでは評価関数を使って最良の手を選ぶ必要があります。
    first_move = valid_moves[0]
    
    # --- 3. 決定した手を返す ---
    return first_move


# myai 関数とは別に、オセロ盤の構造を理解するための例
# othello.play に渡される board の形式は以下の通りです
EXAMPLE_BOARD = [
    [0, 0, 0, 0, 0, 0, 0, 0],  # 0行目
    [0, 0, 0, 0, 0, 0, 0, 0],  # 1行目
    [0, 0, 0, 0, 0, 0, 0, 0],  # 2行目
    [0, 0, 0, 1, 2, 0, 0, 0],  # 3行目 (中央の初期配置)
    [0, 0, 0, 2, 1, 0, 0, 0],  # 4行目 (中央の初期配置)
    [0, 0, 0, 0, 0, 0, 0, 0],  # 5行目
    [0, 0, 0, 0, 0, 0, 0, 0],  # 6行目
    [0, 0, 0, 0, 0, 0, 0, 0],  # 7行目
]
# board[r][c] でアクセスします。例: board[3][3] は 1 (黒)
